extends ../layouts/dashboard

block content
  div(x-data="chatController()" x-init="init()" @keydown.escape="showSettings = false")
    .flex.flex-col(style="height: calc(100vh - 12rem)")

      //- Chat Header
      .bg-white.rounded-t-lg.shadow.px-6.py-4.border-b.border-gray-200
        .flex.items-center.justify-between
          div
            h2.text-xl.font-semibold.text-gray-900 Chat with #{agentName}
            p.text-sm.text-gray-600.mt-1(x-show="messageCount > 0" x-cloak)
              span(x-text="`${messageCount} messages in this conversation`")

          .flex.items-center.gap-2
            button.px-4.py-2.text-sm.text-gray-600.rounded(
              @click="clearChat()"
              class="hover:bg-gray-100"
              title="Clear conversation"
            )
              svg.w-5.h-5.inline(fill="none" stroke="currentColor" viewBox="0 0 24 24")
                path(stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16")
              span.ml-2 Clear

      //- Messages Container
      .flex-1.overflow-y-auto.bg-gray-50.px-6.py-4(
        x-ref="messagesContainer"
        @scroll.debounce="checkScrollPosition()"
      )
        //- Loading state
        div(x-show="loading && messages.length === 0" x-cloak)
          .flex.items-center.justify-center.h-full.text-gray-500
            svg.animate-spin.h-8.w-8.mr-3(fill="none" viewBox="0 0 24 24")
              circle.opacity-25(cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4")
              path.opacity-75(fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z")
            span Loading conversation...

        //- Empty state
        div(x-show="!loading && messages.length === 0" x-cloak)
          .flex.flex-col.items-center.justify-center.h-full.text-center.px-4
            svg.w-16.h-16.text-gray-400.mb-4(fill="none" stroke="currentColor" viewBox="0 0 24 24")
              path(stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z")
            h3.text-lg.font-medium.text-gray-900.mb-2 Start a conversation
            p.text-gray-600 Ask #{agentName} anything. Your conversation history is saved automatically.

        //- Messages
        .space-y-4(x-show="messages.length > 0" x-cloak)
          template(x-for="(message, index) in messages" :key="message.id || index")
            div(:class="message.role === 'user' ? 'flex justify-end' : 'flex justify-start'")
              .max-w-3xl(
                :class="message.role === 'user' ? 'bg-blue-600 text-white' : 'bg-white text-gray-900'"
                class="rounded-lg px-4 py-3 shadow"
              )
                .flex.items-start.gap-3
                  //- Avatar
                  div(x-show="message.role === 'assistant'")
                    .w-8.h-8.rounded-full.bg-gray-900.text-white.flex.items-center.justify-center.text-sm.font-medium
                      span #{agentName.charAt(0).toUpperCase()}

                  //- Message content
                  .flex-1.min-w-0
                    .prose.prose-sm.max-w-none(
                      :class="message.role === 'user' ? 'prose-invert' : ''"
                      x-html="formatMessage(message.content)"
                    )

                    //- Timestamp
                    .text-xs.mt-2.opacity-75(x-text="formatTimestamp(message.timestamp)")

        //- Streaming message (assistant typing)
        div(x-show="streaming && streamingMessage" x-cloak)
          .flex.justify-start.mt-4
            .max-w-3xl.bg-white.text-gray-900.rounded-lg.px-4.py-3.shadow
              .flex.items-start.gap-3
                .w-8.h-8.rounded-full.bg-gray-900.text-white.flex.items-center.justify-center.text-sm.font-medium
                  span #{agentName.charAt(0).toUpperCase()}

                .flex-1.min-w-0
                  .prose.prose-sm.max-w-none(x-html="formatMessage(streamingMessage)")

                  //- Typing indicator
                  .flex.items-center.gap-1.mt-2
                    .w-2.h-2.bg-gray-400.rounded-full.animate-bounce(style="animation-delay: 0ms")
                    .w-2.h-2.bg-gray-400.rounded-full.animate-bounce(style="animation-delay: 150ms")
                    .w-2.h-2.bg-gray-400.rounded-full.animate-bounce(style="animation-delay: 300ms")

        //- Pending Approvals
        template(x-for="(approval, index) in pendingApprovals" :key="approval.modId")
          .flex.justify-start.mt-4
            .max-w-3xl.w-full.bg-amber-50.border.border-amber-200.rounded-lg.shadow
              //- Header
              .px-4.py-3.border-b.border-amber-200.bg-amber-100.rounded-t-lg
                .flex.items-center.justify-between
                  .flex.items-center.gap-2
                    svg.w-5.h-5.text-amber-600(fill="none" stroke="currentColor" viewBox="0 0 24 24")
                      path(stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z")
                    span.text-sm.font-medium.text-amber-800 Approval Required
                  span.text-xs.px-2.py-1.bg-amber-200.text-amber-700.rounded(x-text="approval.operation === 'create' ? 'New File' : 'Modify File'")

              //- File path
              .px-4.py-2.border-b.border-amber-100
                .flex.items-center.gap-2
                  svg.w-4.h-4.text-gray-500(fill="none" stroke="currentColor" viewBox="0 0 24 24")
                    path(stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z")
                  code.text-sm.text-gray-700(x-text="approval.filePath")

              //- Diff preview
              .px-4.py-3.max-h-64.overflow-auto
                pre.text-xs.font-mono.whitespace-pre-wrap.leading-relaxed(x-html="formatDiff(approval.diff)")

              //- Action buttons
              .px-4.py-3.bg-gray-50.border-t.border-amber-100.rounded-b-lg
                .flex.items-center.justify-end.gap-3
                  button.px-4.py-2.text-sm.font-medium.text-gray-700.bg-white.border.border-gray-300.rounded-md(
                    @click="rejectApproval(approval.modId)"
                    :disabled="approval.processing"
                    class="hover:bg-gray-50 disabled:opacity-50"
                  )
                    span(x-show="!approval.processing") Reject
                    span(x-show="approval.processing" x-cloak) Processing...

                  button.px-4.py-2.text-sm.font-medium.text-white.bg-green-600.rounded-md(
                    @click="approveModification(approval.modId)"
                    :disabled="approval.processing"
                    class="hover:bg-green-700 disabled:opacity-50"
                  )
                    span(x-show="!approval.processing") Approve & Commit
                    span(x-show="approval.processing" x-cloak) Committing...

      //- Input Area
      .bg-white.rounded-b-lg.shadow.px-6.py-4.border-t.border-gray-200
        form(@submit.prevent="sendMessage()" x-ref="messageForm")
          .flex.items-end.gap-4
            .flex-1
              textarea.w-full.px-4.py-3.border.border-gray-300.rounded-lg.resize-none(
                x-model="newMessage"
                x-ref="messageInput"
                @keydown.enter.prevent="handleEnterKey($event)"
                :disabled="streaming"
                placeholder="Type your message..."
                rows="1"
                maxlength="10000"
                class="focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              )
              .text-xs.text-gray-500.mt-1(x-show="newMessage.length > 0" x-cloak)
                span(x-text="`${newMessage.length} / 10000`")

            button.px-6.py-3.bg-blue-600.text-white.rounded-lg.font-medium(
              type="submit"
              :disabled="!newMessage.trim() || streaming"
              class="hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            )
              span(x-show="!streaming") Send
              span(x-show="streaming" x-cloak)
                svg.animate-spin.h-5.w-5.inline(fill="none" viewBox="0 0 24 24")
                  circle.opacity-25(cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4")
                  path.opacity-75(fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z")

  //- Alpine.js Chat Controller
  script.
    function chatController() {
      return {
        messages: [],
        newMessage: '',
        streaming: false,
        streamingMessage: '',
        loading: true,
        messageCount: 0,
        conversationId: null,
        eventSource: null,
        unsubscribe: null,
        autoScroll: true,
        pendingApprovals: [],

        async init() {
          try {
            // Get or create conversation
            const response = await fetch('/dashboard/api/chat/conversation', {
              headers: {
                'X-CSRF-Token': window.csrfToken
              }
            });

            if (!response.ok) {
              throw new Error('Failed to load conversation');
            }

            const data = await response.json();
            this.conversationId = data.conversationId;

            // Load initial messages
            await this.loadMessages();

            // Subscribe to real-time updates via Firestore
            this.subscribeToMessages();

            this.loading = false;

            // Focus input
            this.$nextTick(() => {
              this.$refs.messageInput.focus();
            });

          } catch (error) {
            console.error('Chat initialization failed:', error);
            this.loading = false;
          }
        },

        async loadMessages() {
          try {
            const response = await fetch(`/dashboard/api/chat/messages?conversationId=${this.conversationId}`, {
              headers: {
                'X-CSRF-Token': window.csrfToken
              }
            });

            if (response.ok) {
              const data = await response.json();
              this.messages = data.messages || [];
              this.messageCount = this.messages.length;
              this.scrollToBottom();
            }
          } catch (error) {
            console.error('Failed to load messages:', error);
          }
        },

        subscribeToMessages() {
          // DISABLED: Polling not needed since messages are added immediately via SSE
          // Real-time Firestore listeners would be implemented here in the future
          // For now, messages are synced via:
          // 1. Initial load in loadMessages()
          // 2. User messages added immediately in sendMessage()
          // 3. Assistant messages added immediately via SSE stream
        },

        getLastMessageTime() {
          if (this.messages.length === 0) return 0;
          const lastMsg = this.messages[this.messages.length - 1];
          return lastMsg.timestamp?._seconds || 0;
        },

        async sendMessage() {
          if (!this.newMessage.trim() || this.streaming) return;

          const message = this.newMessage.trim();
          this.newMessage = '';

          // Add user message to UI immediately
          this.messages.push({
            id: `temp_${Date.now()}`,
            role: 'user',
            content: message,
            timestamp: { _seconds: Math.floor(Date.now() / 1000) }
          });

          this.messageCount++;
          this.scrollToBottom();

          // Stream response via SSE
          this.streaming = true;
          this.streamingMessage = '';

          try {
            const response = await fetch('/dashboard/api/chat/stream', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.csrfToken
              },
              body: JSON.stringify({
                message,
                conversationId: this.conversationId
              })
            });

            if (!response.ok) {
              throw new Error('Failed to send message');
            }

            // Read SSE stream
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let currentEventType = 'message';

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value);
              const lines = chunk.split('\n');

              for (const line of lines) {
                // Track event type
                if (line.startsWith('event: ')) {
                  currentEventType = line.slice(7).trim();
                  continue;
                }

                if (line.startsWith('data: ')) {
                  const data = JSON.parse(line.slice(6));

                  // Handle approval events
                  if (currentEventType === 'approval' && data.approval) {
                    this.pendingApprovals.push({
                      ...data.approval,
                      processing: false
                    });
                    if (this.autoScroll) {
                      this.scrollToBottom();
                    }
                    continue;
                  }

                  if (data.text) {
                    this.streamingMessage += data.text;
                    if (this.autoScroll) {
                      this.scrollToBottom();
                    }
                  }

                  if (data.status === 'complete') {
                    // Add assistant message to history
                    this.messages.push({
                      id: `msg_${Date.now()}`,
                      role: 'assistant',
                      content: this.streamingMessage,
                      timestamp: { _seconds: Math.floor(Date.now() / 1000) }
                    });
                    this.messageCount++;
                    this.streamingMessage = '';
                  }

                  if (data.error) {
                    console.error('Streaming error:', data.error);
                    this.streamingMessage = '';
                  }
                }
              }
            }

          } catch (error) {
            console.error('Failed to send message:', error);
            alert('Failed to send message. Please try again.');
          } finally {
            this.streaming = false;
            this.scrollToBottom();
            this.$refs.messageInput.focus();
          }
        },

        async clearChat() {
          if (!confirm('Are you sure you want to clear this conversation? This cannot be undone.')) {
            return;
          }

          try {
            const response = await fetch('/dashboard/api/chat/clear', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.csrfToken
              },
              body: JSON.stringify({
                conversationId: this.conversationId
              })
            });

            if (response.ok) {
              this.messages = [];
              this.messageCount = 0;
              this.streamingMessage = '';
            }
          } catch (error) {
            console.error('Failed to clear chat:', error);
            alert('Failed to clear conversation. Please try again.');
          }
        },

        handleEnterKey(event) {
          if (!event.shiftKey) {
            // Enter without shift = send
            this.sendMessage();
          } else {
            // Shift+Enter = new line (default behavior)
          }
        },

        scrollToBottom() {
          this.$nextTick(() => {
            const container = this.$refs.messagesContainer;
            if (container) {
              container.scrollTop = container.scrollHeight;
            }
          });
        },

        checkScrollPosition() {
          const container = this.$refs.messagesContainer;
          if (!container) return;

          const threshold = 100;
          const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
          this.autoScroll = isNearBottom;
        },

        formatMessage(content) {
          if (!content) return '';

          // Simple markdown-like formatting
          let formatted = content
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.+?)\*/g, '<em>$1</em>')
            .replace(/`(.+?)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>');

          return formatted;
        },

        formatTimestamp(timestamp) {
          if (!timestamp) return '';

          const date = timestamp._seconds
            ? new Date(timestamp._seconds * 1000)
            : new Date(timestamp);

          const now = new Date();
          const diff = now - date;

          // Less than 1 minute
          if (diff < 60000) {
            return 'Just now';
          }

          // Less than 1 hour
          if (diff < 3600000) {
            const minutes = Math.floor(diff / 60000);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
          }

          // Less than 24 hours
          if (diff < 86400000) {
            const hours = Math.floor(diff / 3600000);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
          }

          // Format as date/time
          return date.toLocaleString();
        },

        formatDiff(diff) {
          if (!diff) return '<span class="text-gray-500">No changes to preview</span>';

          // Escape HTML and format diff lines with colors
          const escaped = diff
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

          return escaped.split('\n').map(line => {
            if (line.startsWith('+++ ') || line.startsWith('--- ')) {
              return `<span class="text-gray-600 font-semibold">${line}</span>`;
            } else if (line.startsWith('+')) {
              return `<span class="text-green-600 bg-green-50">${line}</span>`;
            } else if (line.startsWith('-')) {
              return `<span class="text-red-600 bg-red-50">${line}</span>`;
            }
            return `<span class="text-gray-600">${line}</span>`;
          }).join('\n');
        },

        async approveModification(modId) {
          const approval = this.pendingApprovals.find(a => a.modId === modId);
          if (!approval || approval.processing) return;

          approval.processing = true;

          try {
            const response = await fetch(`/dashboard/api/chat/approve/${modId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.csrfToken
              }
            });

            const result = await response.json();

            if (response.ok && result.success) {
              // Remove from pending approvals
              this.pendingApprovals = this.pendingApprovals.filter(a => a.modId !== modId);

              // Add success message to chat
              this.messages.push({
                id: `msg_${Date.now()}`,
                role: 'assistant',
                content: `File **${approval.filePath}** has been committed successfully.\n\nCommit: \`${result.commitSha?.substring(0, 7) || 'unknown'}\``,
                timestamp: { _seconds: Math.floor(Date.now() / 1000) }
              });
              this.messageCount++;
              this.scrollToBottom();
            } else {
              alert(`Failed to approve: ${result.error || 'Unknown error'}`);
              approval.processing = false;
            }
          } catch (error) {
            console.error('Approval failed:', error);
            alert('Failed to approve modification. Please try again.');
            approval.processing = false;
          }
        },

        async rejectApproval(modId) {
          const approval = this.pendingApprovals.find(a => a.modId === modId);
          if (!approval || approval.processing) return;

          if (!confirm('Are you sure you want to reject this change? The file will not be modified.')) {
            return;
          }

          approval.processing = true;

          try {
            const response = await fetch(`/dashboard/api/chat/reject/${modId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.csrfToken
              }
            });

            const result = await response.json();

            if (response.ok && result.success) {
              // Remove from pending approvals
              this.pendingApprovals = this.pendingApprovals.filter(a => a.modId !== modId);

              // Add rejection message to chat
              this.messages.push({
                id: `msg_${Date.now()}`,
                role: 'assistant',
                content: `Change to **${approval.filePath}** was rejected and will not be applied.`,
                timestamp: { _seconds: Math.floor(Date.now() / 1000) }
              });
              this.messageCount++;
              this.scrollToBottom();
            } else {
              alert(`Failed to reject: ${result.error || 'Unknown error'}`);
              approval.processing = false;
            }
          } catch (error) {
            console.error('Rejection failed:', error);
            alert('Failed to reject modification. Please try again.');
            approval.processing = false;
          }
        }
      }
    }
