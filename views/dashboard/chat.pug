extends ../layouts/dashboard

block content
  div(x-data="chatController()" x-init="init()" @keydown.escape="showSettings = false")
    .flex.flex-col(style="height: calc(100vh - 12rem)")

      //- Chat Header
      .bg-white.rounded-t-lg.shadow.px-6.py-4.border-b.border-gray-200
        .flex.items-center.justify-between
          div
            h2.text-xl.font-semibold.text-gray-900 Chat with #{agentName}
            p.text-sm.text-gray-600.mt-1(x-show="messageCount > 0" x-cloak)
              span(x-text="`${messageCount} messages in this conversation`")

          .flex.items-center.gap-2
            button.px-4.py-2.text-sm.text-gray-600.rounded(
              @click="clearChat()"
              class="hover:bg-gray-100"
              title="Clear conversation"
            )
              svg.w-5.h-5.inline(fill="none" stroke="currentColor" viewBox="0 0 24 24")
                path(stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16")
              span.ml-2 Clear

      //- Messages Container
      .flex-1.overflow-y-auto.bg-gray-50.px-6.py-4(
        x-ref="messagesContainer"
        @scroll.debounce="checkScrollPosition()"
      )
        //- Loading state
        div(x-show="loading && messages.length === 0" x-cloak)
          .flex.items-center.justify-center.h-full.text-gray-500
            svg.animate-spin.h-8.w-8.mr-3(fill="none" viewBox="0 0 24 24")
              circle.opacity-25(cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4")
              path.opacity-75(fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z")
            span Loading conversation...

        //- Empty state
        div(x-show="!loading && messages.length === 0" x-cloak)
          .flex.flex-col.items-center.justify-center.h-full.text-center.px-4
            svg.w-16.h-16.text-gray-400.mb-4(fill="none" stroke="currentColor" viewBox="0 0 24 24")
              path(stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z")
            h3.text-lg.font-medium.text-gray-900.mb-2 Start a conversation
            p.text-gray-600 Ask #{agentName} anything. Your conversation history is saved automatically.

        //- Messages
        .space-y-4(x-show="messages.length > 0" x-cloak)
          template(x-for="(message, index) in messages" :key="message.id || index")
            div(:class="message.role === 'user' ? 'flex justify-end' : 'flex justify-start'")
              .max-w-3xl(
                :class="message.role === 'user' ? 'bg-blue-600 text-white' : 'bg-white text-gray-900'"
                class="rounded-lg px-4 py-3 shadow"
              )
                .flex.items-start.gap-3
                  //- Avatar
                  div(x-show="message.role === 'assistant'")
                    .w-8.h-8.rounded-full.bg-gray-900.text-white.flex.items-center.justify-center.text-sm.font-medium
                      span #{agentName.charAt(0).toUpperCase()}

                  //- Message content
                  .flex-1.min-w-0
                    .prose.prose-sm.max-w-none(
                      :class="message.role === 'user' ? 'prose-invert' : ''"
                      x-html="formatMessage(message.content)"
                    )

                    //- Timestamp
                    .text-xs.mt-2.opacity-75(x-text="formatTimestamp(message.timestamp)")

        //- Streaming message (assistant typing)
        div(x-show="streaming && streamingMessage" x-cloak)
          .flex.justify-start.mt-4
            .max-w-3xl.bg-white.text-gray-900.rounded-lg.px-4.py-3.shadow
              .flex.items-start.gap-3
                .w-8.h-8.rounded-full.bg-gray-900.text-white.flex.items-center.justify-center.text-sm.font-medium
                  span #{agentName.charAt(0).toUpperCase()}

                .flex-1.min-w-0
                  .prose.prose-sm.max-w-none(x-html="formatMessage(streamingMessage)")

                  //- Typing indicator
                  .flex.items-center.gap-1.mt-2
                    .w-2.h-2.bg-gray-400.rounded-full.animate-bounce(style="animation-delay: 0ms")
                    .w-2.h-2.bg-gray-400.rounded-full.animate-bounce(style="animation-delay: 150ms")
                    .w-2.h-2.bg-gray-400.rounded-full.animate-bounce(style="animation-delay: 300ms")

      //- Input Area
      .bg-white.rounded-b-lg.shadow.px-6.py-4.border-t.border-gray-200
        form(@submit.prevent="sendMessage()" x-ref="messageForm")
          .flex.items-end.gap-4
            .flex-1
              textarea.w-full.px-4.py-3.border.border-gray-300.rounded-lg.resize-none(
                x-model="newMessage"
                x-ref="messageInput"
                @keydown.enter.prevent="handleEnterKey($event)"
                :disabled="streaming"
                placeholder="Type your message..."
                rows="1"
                maxlength="10000"
                class="focus:ring-2 focus:ring-blue-500 focus:border-blue-500 disabled:bg-gray-100"
              )
              .text-xs.text-gray-500.mt-1(x-show="newMessage.length > 0" x-cloak)
                span(x-text="`${newMessage.length} / 10000`")

            button.px-6.py-3.bg-blue-600.text-white.rounded-lg.font-medium(
              type="submit"
              :disabled="!newMessage.trim() || streaming"
              class="hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            )
              span(x-show="!streaming") Send
              span(x-show="streaming" x-cloak)
                svg.animate-spin.h-5.w-5.inline(fill="none" viewBox="0 0 24 24")
                  circle.opacity-25(cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4")
                  path.opacity-75(fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z")

  //- Alpine.js Chat Controller
  script.
    function chatController() {
      return {
        messages: [],
        newMessage: '',
        streaming: false,
        streamingMessage: '',
        loading: true,
        messageCount: 0,
        conversationId: null,
        eventSource: null,
        unsubscribe: null,
        autoScroll: true,

        async init() {
          try {
            // Get or create conversation
            const response = await fetch('/dashboard/api/chat/conversation', {
              headers: {
                'X-CSRF-Token': window.csrfToken
              }
            });

            if (!response.ok) {
              throw new Error('Failed to load conversation');
            }

            const data = await response.json();
            this.conversationId = data.conversationId;

            // Load initial messages
            await this.loadMessages();

            // Subscribe to real-time updates via Firestore
            this.subscribeToMessages();

            this.loading = false;

            // Focus input
            this.$nextTick(() => {
              this.$refs.messageInput.focus();
            });

          } catch (error) {
            console.error('Chat initialization failed:', error);
            this.loading = false;
          }
        },

        async loadMessages() {
          try {
            const response = await fetch(`/dashboard/api/chat/messages?conversationId=${this.conversationId}`, {
              headers: {
                'X-CSRF-Token': window.csrfToken
              }
            });

            if (response.ok) {
              const data = await response.json();
              this.messages = data.messages || [];
              this.messageCount = this.messages.length;
              this.scrollToBottom();
            }
          } catch (error) {
            console.error('Failed to load messages:', error);
          }
        },

        subscribeToMessages() {
          // Use Firestore real-time listeners
          // For now, poll every 2 seconds for new messages
          setInterval(async () => {
            if (!this.streaming && this.conversationId) {
              const response = await fetch(`/dashboard/api/chat/messages?conversationId=${this.conversationId}&after=${this.getLastMessageTime()}`, {
                headers: {
                  'X-CSRF-Token': window.csrfToken
                }
              });

              if (response.ok) {
                const data = await response.json();
                if (data.messages && data.messages.length > 0) {
                  this.messages.push(...data.messages);
                  this.messageCount = this.messages.length;

                  if (this.autoScroll) {
                    this.scrollToBottom();
                  }
                }
              }
            }
          }, 2000);
        },

        getLastMessageTime() {
          if (this.messages.length === 0) return 0;
          const lastMsg = this.messages[this.messages.length - 1];
          return lastMsg.timestamp?._seconds || 0;
        },

        async sendMessage() {
          if (!this.newMessage.trim() || this.streaming) return;

          const message = this.newMessage.trim();
          this.newMessage = '';

          // Add user message to UI immediately
          this.messages.push({
            id: `temp_${Date.now()}`,
            role: 'user',
            content: message,
            timestamp: { _seconds: Math.floor(Date.now() / 1000) }
          });

          this.messageCount++;
          this.scrollToBottom();

          // Stream response via SSE
          this.streaming = true;
          this.streamingMessage = '';

          try {
            const response = await fetch('/dashboard/api/chat/stream', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.csrfToken
              },
              body: JSON.stringify({
                message,
                conversationId: this.conversationId
              })
            });

            if (!response.ok) {
              throw new Error('Failed to send message');
            }

            // Read SSE stream
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value);
              const lines = chunk.split('\n');

              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  const data = JSON.parse(line.slice(6));

                  if (data.text) {
                    this.streamingMessage += data.text;
                    if (this.autoScroll) {
                      this.scrollToBottom();
                    }
                  }

                  if (data.status === 'complete') {
                    // Add assistant message to history
                    this.messages.push({
                      id: `msg_${Date.now()}`,
                      role: 'assistant',
                      content: this.streamingMessage,
                      timestamp: { _seconds: Math.floor(Date.now() / 1000) }
                    });
                    this.messageCount++;
                    this.streamingMessage = '';
                  }

                  if (data.error) {
                    console.error('Streaming error:', data.error);
                    this.streamingMessage = '';
                  }
                }
              }
            }

          } catch (error) {
            console.error('Failed to send message:', error);
            alert('Failed to send message. Please try again.');
          } finally {
            this.streaming = false;
            this.scrollToBottom();
            this.$refs.messageInput.focus();
          }
        },

        async clearChat() {
          if (!confirm('Are you sure you want to clear this conversation? This cannot be undone.')) {
            return;
          }

          try {
            const response = await fetch('/dashboard/api/chat/clear', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': window.csrfToken
              },
              body: JSON.stringify({
                conversationId: this.conversationId
              })
            });

            if (response.ok) {
              this.messages = [];
              this.messageCount = 0;
              this.streamingMessage = '';
            }
          } catch (error) {
            console.error('Failed to clear chat:', error);
            alert('Failed to clear conversation. Please try again.');
          }
        },

        handleEnterKey(event) {
          if (!event.shiftKey) {
            // Enter without shift = send
            this.sendMessage();
          } else {
            // Shift+Enter = new line (default behavior)
          }
        },

        scrollToBottom() {
          this.$nextTick(() => {
            const container = this.$refs.messagesContainer;
            if (container) {
              container.scrollTop = container.scrollHeight;
            }
          });
        },

        checkScrollPosition() {
          const container = this.$refs.messagesContainer;
          if (!container) return;

          const threshold = 100;
          const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < threshold;
          this.autoScroll = isNearBottom;
        },

        formatMessage(content) {
          if (!content) return '';

          // Simple markdown-like formatting
          let formatted = content
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.+?)\*/g, '<em>$1</em>')
            .replace(/`(.+?)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>');

          return formatted;
        },

        formatTimestamp(timestamp) {
          if (!timestamp) return '';

          const date = timestamp._seconds
            ? new Date(timestamp._seconds * 1000)
            : new Date(timestamp);

          const now = new Date();
          const diff = now - date;

          // Less than 1 minute
          if (diff < 60000) {
            return 'Just now';
          }

          // Less than 1 hour
          if (diff < 3600000) {
            const minutes = Math.floor(diff / 60000);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
          }

          // Less than 24 hours
          if (diff < 86400000) {
            const hours = Math.floor(diff / 3600000);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
          }

          // Format as date/time
          return date.toLocaleString();
        }
      }
    }
